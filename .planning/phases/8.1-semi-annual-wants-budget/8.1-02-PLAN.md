---
phase: 8.1-semi-annual-wants-budget
plan: 02
type: execute
---

<objective>
Extend SMS webhook to support wants transactions via "wants" keyword prefix, with automatic period detection and idempotency.

Purpose: Enable SMS-based wants transaction logging using the established Twilio integration, allowing users to text "wants 25 coffee" to create wants transactions.
Output: Updated SMS parser and webhook that routes wants transactions to the wants_transactions table with proper period association.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/8.1-semi-annual-wants-budget/8.1-01-SUMMARY.md
@.planning/phases/05-sms-integration/05-01-SUMMARY.md
@app/api/sms/route.ts
@lib/twilio/parser.ts
@lib/wants/periods.ts

**Tech stack available:**
- Twilio SDK v5.11.2 (Phase 5)
- SMS webhook with signature validation (Phase 5)
- Wants budget schema with period tracking (Phase 8.1 Plan 1)
- Period helper utilities (Phase 8.1 Plan 1)

**Established patterns:**
- SMS format: "amount note" creates regular transaction (Phase 5)
- Webhook validation: signature → idempotency → parse → create → respond (Phase 5)
- Idempotency via twilio_message_id unique constraint (Phase 5)
- Silent success, error SMS only on parse failure (Phase 5)
- Parser returns { amount, note } or { error } (Phase 5)

**Constraining decisions:**
- Phase 5: Simplified SMS format prioritizes UX over feature density
- Phase 5: Direct Supabase insert for speed (15-second webhook timeout)
- Phase 8.1 Plan 1: Semi-annual periods with automatic current period detection
- Phase 8.1 Requirements: Extend parser to detect "wants" keyword, route to wants_transactions

**Issues being addressed:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SMS parser to detect wants transactions</name>
  <files>lib/twilio/parser.ts</files>
  <action>
Update the parseSMS function to detect and parse wants transactions.

**Detection logic:**
- If SMS body starts with "wants" or "want" (case-insensitive), treat as wants transaction
- Strip "wants"/"want" prefix and parse remainder as "amount note"
- Return { type: 'wants', amount, note } for wants transactions
- Return { type: 'regular', amount, note } for regular transactions (backward compatible)
- Return { error: string } on parse failure

**Example formats:**
- "wants 25 coffee" → { type: 'wants', amount: 25, note: 'coffee' }
- "want 30.50 lunch out" → { type: 'wants', amount: 30.50, note: 'lunch out' }
- "25 groceries" → { type: 'regular', amount: 25, note: 'groceries' } (unchanged)

**Implementation approach:**
1. Check first word: if matches /^wants?$/i, set type='wants', remove prefix
2. Parse remaining text with existing amount/note regex logic
3. Preserve all existing regular transaction parsing (no breaking changes)

Use existing permissive parsing patterns from Phase 5 (accept $25, 25, 25.50 formats).

Avoid creating new parser functions (extend existing parseSMS). Avoid complex regex (simple prefix detection + existing parse logic). Avoid changing return type for regular transactions (only add 'type' field).
  </action>
  <verify>Unit tests pass if they exist, sample parsing works: parseSMS("wants 25 coffee") returns { type: 'wants', amount: 25, note: 'coffee' }</verify>
  <done>Parser detects wants keyword, correctly strips prefix, preserves regular transaction parsing, returns type field for routing</done>
</task>

<task type="auto">
  <name>Task 2: Create wants budget lookup utility</name>
  <files>lib/wants/queries.ts</files>
  <action>
Create server-side utility to find or create current period's wants budget:

```typescript
// lib/wants/queries.ts
import { createClient } from '@/lib/supabase/server';
import { getCurrentWantsPeriod } from './periods';

const TEMP_USER_ID = '00000000-0000-0000-0000-000000000000';

export async function findOrCreateCurrentWantsBudget() {
  const supabase = await createClient();
  const period = getCurrentWantsPeriod();

  // Try to find existing budget for current period
  const { data: existing } = await supabase
    .from('wants_budgets')
    .select('id, total_amount, period_start, period_end')
    .eq('user_id', TEMP_USER_ID)
    .eq('period_start', period.periodStart)
    .maybeSingle();

  if (existing) {
    return { budget: existing, created: false };
  }

  // No budget exists for current period - return null so webhook can respond appropriately
  // (Don't auto-create budget - user should set it up first via UI)
  return { budget: null, created: false };
}

export async function createWantsTransaction(params: {
  wantsBudgetId: number;
  amount: number;
  note: string | null;
  twilioMessageId: string;
  twilioFrom: string;
}) {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('wants_transactions')
    .insert({
      user_id: TEMP_USER_ID,
      wants_budget_id: params.wantsBudgetId,
      amount: params.amount,
      note: params.note,
      source: 'sms',
      twilio_message_id: params.twilioMessageId,
      transaction_date: new Date().toISOString().split('T')[0], // YYYY-MM-DD
    })
    .select('id')
    .single();

  if (error) throw error;
  return data;
}
```

Follow existing Supabase query patterns from the codebase. Return structured results for easy error handling in webhook.

Avoid creating budgets automatically (user should configure via UI first). Avoid complex budget selection logic (always use current period). Avoid external date libraries (use simple ISO string splitting like Phase 11).
  </action>
  <verify>npm run build passes, functions compile without TypeScript errors</verify>
  <done>Utility functions created, budget lookup returns existing budget or null, transaction creation follows established patterns, build passes</done>
</task>

<task type="auto">
  <name>Task 3: Update SMS webhook to route wants transactions</name>
  <files>app/api/sms/route.ts</files>
  <action>
Extend the SMS webhook to handle wants transactions while preserving regular transaction flow.

**Changes needed:**

1. Import new utilities:
   - `import { findOrCreateCurrentWantsBudget, createWantsTransaction } from '@/lib/wants/queries'`

2. After parsing SMS body, check parse result type:
   ```typescript
   const parseResult = parseSMS(smsBody);

   if (parseResult.error) {
     // Existing error handling unchanged
   }

   if (parseResult.type === 'wants') {
     // New wants transaction flow
     const { budget } = await findOrCreateCurrentWantsBudget();

     if (!budget) {
       // No wants budget configured for current period
       const twiml = `<?xml version="1.0" encoding="UTF-8"?><Response><Message>No wants budget set up for current period. Visit app to configure.</Message></Response>`;
       return new NextResponse(twiml, { status: 200, headers: { 'Content-Type': 'text/xml' } });
     }

     // Check idempotency for wants_transactions
     const { data: existingWants } = await supabase
       .from('wants_transactions')
       .select('id')
       .eq('twilio_message_id', MessageSid)
       .maybeSingle();

     if (existingWants) {
       console.log('Duplicate wants SMS detected:', MessageSid);
       return new NextResponse('<?xml version="1.0" encoding="UTF-8"?><Response></Response>', { status: 200, headers: { 'Content-Type': 'text/xml' } });
     }

     // Create wants transaction
     await createWantsTransaction({
       wantsBudgetId: budget.id,
       amount: parseResult.amount,
       note: parseResult.note || null,
       twilioMessageId: MessageSid,
       twilioFrom: From,
     });

     console.log('Wants transaction created via SMS:', MessageSid);
     return new NextResponse('<?xml version="1.0" encoding="UTF-8"?><Response></Response>', { status: 200, headers: { 'Content-Type': 'text/xml' } });
   }

   // Regular transaction flow continues unchanged below...
   ```

3. Keep all existing code for regular transactions (type === 'regular' or undefined)

Preserve existing webhook structure (validation, idempotency, error handling). Use same TwiML response patterns. Log wants transactions distinctly for debugging.

Avoid refactoring the entire webhook (extend, don't rewrite). Avoid complex branching (simple if-else based on type). Avoid breaking regular transaction flow (all existing SMS should work exactly as before).
  </action>
  <verify>curl test with "wants 25 test" returns 200, regular SMS "25 test" still works, build passes without errors</verify>
  <done>Webhook routes wants transactions to wants_transactions table, checks idempotency correctly, responds with helpful error if budget missing, regular transactions unchanged</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without TypeScript errors
- [ ] Parser correctly detects "wants" keyword (case-insensitive)
- [ ] Webhook creates wants_transaction when budget exists
- [ ] Webhook returns helpful error when no budget configured
- [ ] Regular SMS transactions still work exactly as before
- [ ] Idempotency works for both transaction types
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SMS format extended without breaking existing behavior
- Wants transactions route to correct table with period association
- Idempotency maintained via twilio_message_id
- Helpful user feedback when budget not configured
- No regression in regular transaction SMS flow
</success_criteria>

<output>
After completion, create `.planning/phases/8.1-semi-annual-wants-budget/8.1-02-SUMMARY.md`:

# Phase 8.1 Plan 2: SMS Integration Extension Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- Extended SMS parser to detect "wants"/"want" keyword prefix
- Webhook routes wants transactions to wants_transactions table
- Automatic current period budget lookup with helpful error messages
- Idempotency support for wants SMS via twilio_message_id
- Backward compatible - regular transactions work unchanged

## Files Created/Modified

- `lib/twilio/parser.ts` - Added wants detection to parser
- `lib/wants/queries.ts` - Budget lookup and transaction creation utilities
- `app/api/sms/route.ts` - Extended webhook to route wants transactions

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 8.1-03-PLAN.md (wants budget UI foundation and overview page)
</output>
